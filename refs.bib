@string{pacmpl = "Proceedings of the ACM on Programming Languages"}

@article{imp,
author = {Irons, Edgar T.},
title = {Experience with an Extensible Language},
year = {1970},
issue_date = {Jan. 1970},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {13},
number = {1},
issn = {0001-0782},
url = {https://doi.org/10.1145/361953.361966},
doi = {10.1145/361953.361966},
abstract = {An operational extensible language system is described. The system and its base language are appraised with respect to efficiency, flexibility, and utility for different categories of users.},
journal = {Commun. ACM},
month = {jan},
pages = {31–40},
numpages = {10},
keywords = {bootstrapping, compiler, extensible, programming languages, ambiguity}
}

@inproceedings{10.1145/351240.351266,
author = {Claessen, Koen and Hughes, John},
title = {QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs},
year = {2000},
isbn = {1581132026},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/351240.351266},
doi = {10.1145/351240.351266},
abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
booktitle = {Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming},
pages = {268–279},
numpages = {12},
series = {ICFP '00}
}

@article{qc,
author = {Claessen, Koen and Hughes, John},
title = {QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs},
year = {2000},
issue_date = {Sept. 2000},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/357766.351266},
doi = {10.1145/357766.351266},
abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {268–279},
numpages = {12}
}

@inproceedings{luck,
  author    = {Leonidas Lampropoulos and
               Diane Gallois{-}Wong and
               Catalin Hritcu and
               John Hughes and
               Benjamin C. Pierce and
               Li{-}yao Xia},
  title     = {Beginner's {Luck}: a language for property-based generators},
  booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of
               Programming Languages, {POPL} 2017, Paris, France, January 18-20,
               2017},
  pages     = {114--129},
  year      = {2017},
  url       = {http://dl.acm.org/citation.cfm?id=3009868},
  timestamp = {Wed, 28 Dec 2016 13:22:29 +0100},
  biburl    = {http://dblp2.uni-trier.de/rec/bib/conf/popl/LampropoulosGHH17},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}


@article{gittins1979bandit,
  title={Bandit processes and dynamic allocation indices},
  author={Gittins, John C},
  journal={Journal of the Royal Statistical Society: Series B (Methodological)},
  volume={41},
  number={2},
  pages={148--164},
  year={1979},
  publisher={Wiley Online Library}
}

@article{auer2002finite,
  title={Finite-time analysis of the multiarmed bandit problem},
  author={Auer, Peter and Cesa-Bianchi, Nicolo and Fischer, Paul},
  journal={Machine learning},
  volume={47},
  number={2},
  pages={235--256},
  year={2002},
  publisher={Springer}
}

@article{gggir,
author = {Lampropoulos, Leonidas and Paraskevopoulou, Zoe and Pierce, Benjamin C.},
title = {Generating Good Generators for Inductive Relations},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158133},
doi = {10.1145/3158133},
abstract = {Property-based random testing (PBRT) is widely used in the functional programming and verification communities. For testing simple properties, PBRT tools such as QuickCheck can automatically generate random inputs of a given type. But for more complex properties, effective testing often demands generators for random inputs that belong to a given type and satisfy some logical condition. QuickCheck provides a library of combinators for building such generators by hand, but this can be tedious for simple conditions and error prone for more complex ones. Fortunately, the process can often be automated. The most prominent method, narrowing, works by traversing the structure of the condition, lazily instantiating parts of the data structure as constraints involving them are met.  We show how to use ideas from narrowing to compile a large subclass of Coq's inductive relations into efficient generators, avoiding the interpretive overhead of previous implementations. More importantly, the same compilation technique allows us to produce proof terms certifying that each derived generator is good---i.e., sound and complete with respect to the inductive relation it was derived from. We implement our algorithm as an extension of QuickChick, an existing tool for property-based testing in Coq. We evaluate our method by automatically deriving good generators for the majority of the specifications in Software Foundations, a formalized textbook on programming language foundations.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {45},
numpages = {30},
keywords = {Random Testing, QuickChick, Narrowing, Property-based Testing, QuickCheck, Coq}
}

@inproceedings{ironfleet,
author = {Hawblitzel, Chris and Howell, Jon and Kapritsos, Manos and Lorch, Jacob R. and Parno, Bryan and Roberts, Michael L. and Setty, Srinath and Zill, Brian},
title = {IronFleet: Proving Practical Distributed Systems Correct},
year = {2015},
isbn = {9781450338349},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2815400.2815428},
doi = {10.1145/2815400.2815428},
abstract = {Distributed systems are notorious for harboring subtle bugs. Verification can, in principle, eliminate these bugs a priori, but verification has historically been difficult to apply at full-program scale, much less distributed-system scale.We describe a methodology for building practical and provably correct distributed systems based on a unique blend of TLA-style state-machine refinement and Hoare-logic verification. We demonstrate the methodology on a complex implementation of a Paxos-based replicated state machine library and a lease-based sharded key-value store. We prove that each obeys a concise safety specification, as well as desirable liveness requirements. Each implementation achieves performance competitive with a reference system. With our methodology and lessons learned, we aim to raise the standard for distributed systems from "tested" to "correct."},
booktitle = {Proceedings of the 25th Symposium on Operating Systems Principles},
pages = {1–17},
numpages = {17},
location = {Monterey, California},
series = {SOSP '15}
}

@InProceedings{dafny,
author="Leino, K. Rustan M.",
editor="Clarke, Edmund M.
and Voronkov, Andrei",
title="Dafny: An Automatic Program Verifier for Functional Correctness",
booktitle="Logic for Programming, Artificial Intelligence, and Reasoning",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="348--370",
abstract="Traditionally, the full verification of a program's functional correctness has been obtained with pen and paper or with interactive proof assistants, whereas only reduced verification tasks, such as extended static checking, have enjoyed the automation offered by satisfiability-modulo-theories (SMT) solvers. More recently, powerful SMT solvers and well-designed program verifiers are starting to break that tradition, thus reducing the effort involved in doing full verification.",
isbn="978-3-642-17511-4"
}

@InProceedings{framac,
author="Cuoq, Pascal
and Kirchner, Florent
and Kosmatov, Nikolai
and Prevosto, Virgile
and Signoles, Julien
and Yakobowski, Boris",
editor="Eleftherakis, George
and Hinchey, Mike
and Holcombe, Mike",
title="Frama-C",
booktitle="Software Engineering and Formal Methods",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="233--247",
abstract="Frama-C is a source code analysis platform that aims at conducting verification of industrial-size C programs. It provides its users with a collection of plug-ins that perform static analysis, deductive verification, and testing, for safety- and security-critical software. Collaborative verification across cooperating plug-ins is enabled by their integration on top of a shared kernel and datastructures, and their compliance to a common specification language. This foundational article presents a consolidated view of the platform, its main and composite analyses, and some of its industrial achievements.",
isbn="978-3-642-33826-7"
}

